unit StackUnit;

interface

uses
  OperationsUnit;

type
  PNodeOperat = ^nodeOperat;
  PNodeData = ^nodeData;

nodeOperat = record // ”зел
  operation: char;
  next: PNodeOperat;
  end;

nodeData = record
  Mat: Matrix;
  Number: Real;
  isMatrix: Boolean;
  Next: pNodeData;
  end;

  //-----OPERATION STACK FUNCTIONAL
  procedure pushOperat(Operation: Char);
  function popOperat(): Char;
  function topOperat(): Char;
  function isEmptyOperat(): Boolean;
  procedure removeOperat();
  //---
  //-----DATA STACK FUNCTIONAL
  procedure pushData(Data: Matrix);
  procedure pushNumber(Data: Real);

  function popDataMatrix():Matrix;
  function popDataNumber():Real;

  function topDataNumber():Real;
  function topDataMatrix():Matrix;

  function isLastMatrix():Boolean;

  function isEmptyData():Boolean;

  procedure removeData();
  //---

var
  headOperat: pNodeOperat; //  орень списка, начало списка
  headData: pNodeData;
implementation
//-----OPERATION STACK FUNCTIONAL
procedure pushOperat(Operation: Char);
var
  Temp: pNodeOperat;//переменна€, котора€ будет хранить адрес нового узла
begin
  New(Temp); //выделили блок пам€ти и поместили его в адрес temp
  Temp^.Next := headOperat;
  headOperat := Temp;
  headOperat^.Operation := Operation;
end;

function popOperat():char;
var
  Oper: Char;
  Temp: pNodeOperat;
begin
  Oper := headOperat^.Operation;
  Temp := headOperat;
  headOperat := Temp^.Next;
  Dispose(Temp);
  popOperat := Oper;
end;

function topOperat():char;
begin
  topOperat := headOperat^.Operation;
end;

function isEmptyOperat():Boolean;
begin
  isEmptyOperat := headOperat = NIL;
end;

procedure removeOperat();
var
  Temp: pNodeOperat;
begin
  while headOperat<>NIL do
  begin
    Temp := headOperat;
    headOperat := headOperat^.Next;
    Dispose(Temp);
  end;
end;
//---
//-----DATA STACK FUNCTIONAL
procedure pushData(Data: Matrix);
var
 Temp: pNodeData;
begin
  New(Temp);
  Temp^.Mat := Data;
  Temp^.isMatrix := True;
  Temp^.Next := headData;
  headData := Temp;
end;

procedure pushNumber(Data: Real);
var
  Temp: pNodeData;
begin
  New(Temp);
  Temp^.Number := Data;
  Temp^.isMatrix := False;
  Temp^.Next := headData;
  headData := Temp;
end;

function popDataMatrix():Matrix;
var
  Mat: Matrix;
  Temp: pNodeData;
begin
  Mat := headData^.Mat;
  Temp := headData;
  headData := Temp^.Next;
  Dispose(Temp);
  popDataMatrix := Mat;
end;

function popDataNumber():Real;
var
  Number: Real;
  Temp: pNodeData;
begin
  Number := headData^.Number;
  Temp := headData;
  headData := Temp^.Next;
  Dispose(Temp);
  popDataNumber := Number;
end;

function topDataNumber():Real;
begin
  topDataNumber := headData^.Number;
end;

function topDataMatrix():Matrix;
begin
  topDataMatrix := headData^.Mat;
end;

function isLastMatrix():Boolean;
begin
  isLastMatrix := headData^.isMatrix;
end;

function isEmptyData():Boolean;
begin
   isEmptyData := headData = NIL;
end;

procedure removeData();
var
  Temp: pNodeData;
begin
  while headData<>NIL do
  begin
    Temp := headData;
    headData := headData^.Next;
    Dispose(Temp);
  end;
end;
//---
begin
  headOperat := NIL;
  headData := NIL;
end.


